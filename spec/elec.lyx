#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\use_default_options true
\language french
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
PJ
\begin_inset Newline newline
\end_inset

Protocole de communication
\end_layout

\begin_layout Author
\begin_inset VSpace 13cm
\end_inset


\begin_inset Newline newline
\end_inset

Jérémy Cheynet
\begin_inset Newline newline
\end_inset

Yann Sionneau
\end_layout

\begin_layout Date
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename image/logo_SP.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset

Année 2010
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Théorie
\end_layout

\begin_layout Chapter
Objectifs
\end_layout

\begin_layout Standard
L'objectif de notre projet est de créer un système qui permet de faire communiqu
er toutes sortes d'électronique embarquée entre elles.
 Une des conditions que nous nous sommes fixée, est de faire communiquer
 les appareils sur un seul et unique fil pour pouvoir, dans un second temps,
 faire communiquer ces appareils avec une liaison sans fils.
\end_layout

\begin_layout Standard
Les systèmes embarqués que nous comptons utiliser sont des microcontrôleurs
 et des FPGA
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
FPGA
\emph default
 (field-programmable gate array, réseau matriciel de portes logiques programmabl
es ).
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Afin de faciliter la communication entre les appareils, et l'architecture
 de notre système, nous avons choisi d'utiliser une structure sous forme
 de couches d'abstractions (en s'inspirant du model OSI).
\end_layout

\begin_layout Chapter
Spécifictions
\end_layout

\begin_layout Section
Matériel
\end_layout

\begin_layout Standard
Notre choix étant de faire fonctionner notre système sur plusieurs système
 et différente architecture.
 Pour cela, nous avons décidé de développer notre système sur un microctontrôleu
r et sur un FPGA.
 Nous avons donc choisi, parmi la grande gamme de produits disponibles dans
 ces 2 catégorie, une architecture de microcontrôleur et un type de FPGA.
 
\end_layout

\begin_layout Subsection
Microcontrôleur
\end_layout

\begin_layout Standard
Nous avons choisi d'implémenter notre système sur microcontrôleur car ces
 puces électroniques sont très répandues, très utilisées et faciles d'utilisatio
n.
 En effet, utiliser un microprocesseur oblige de rajouter de la mémoire,
 et des modules externe, tandis qu'un microcontrôleur est autonome.
\end_layout

\begin_layout Standard
Le microcontrôleur que nous utilisons fait partie la gamme ATMega (architecture
 AVR) de chez ATMEL.
 Ce type de microcontrôleur est facilement programmable en C/C++, et se
 trouve pour un prix correct.
\end_layout

\begin_layout Standard
Voici les 3 types de microcontrôleurs que nous allons utiliser
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Description
La
\begin_inset space ~
\end_inset

carte
\begin_inset space ~
\end_inset

arduino
\begin_inset space ~
\end_inset

: Il s'agit d'une carte microcontrôleur toute prète, programmable en C/C++
 avec un logiciel fourni gratuitement.
 Tout les programmes et toutes les shields
\begin_inset Foot
status open

\begin_layout Plain Layout
Petite carte électronique que l'on peut facilement brancher sur la carte
 arduino
\end_layout

\end_inset

 sont open-sources.
 Le microcontrôleur qui se trouve sur la carte est un ATMEGA168 de chez
 ATMEL.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/arduino.jpg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Carte Arduino
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Description
L'ATMEGA324
\begin_inset space ~
\end_inset

: Il s'agit d'un microcontrôleur 40 broches de 32 entrées/sorties de chez
 ATMEL.
 La carte que nous utilisons pour l'utiliser est une carte faite maison,
 et programmée grâce au logiciel libre avrdude à l'aide d'un ISP programmer
 (système libre pour programmer la série avr de chez ATMEL).
 Le programme s'effectue toujours en C/C++ et se compile grâce à la toolchain
 GNU pour l'architecture AVR (avr-gcc, avr-objdump, avr-ld, avr-as etc ...).
\end_layout

\begin_layout Description
L'ATTINY13
\begin_inset space ~
\end_inset

: Microcontrôleur à prix réduit de chez ATMEL.
 Il s'agit d'un petit microcontrôleur de 8 broches, programmable comme l'ATMEGA3
24.
 Là aussi, nous allons designer une carte pour pouvoir faire des tests de
 notre système.
\end_layout

\begin_layout Subsection
FPGA
\end_layout

\begin_layout Standard
Nous avons choisi d'utiliser pour nos tests un Spartan-3A 400k portes (XC3S400A)
 de chez Xilinx.
 Cette puce est présente sur la plaque de développement 
\begin_inset Quotes eld
\end_inset

AVnet Spartan-3A Evaluation Kit
\begin_inset Quotes erd
\end_inset

 en notre possession.
 Un port de 40 pins d'entrées/sorties (GPIOs) est disponible sur cette plaque
 que nous pourront utiliser pour tester le protocole, en la reliant par
 exemple à un Arduino.
 Le bitstream est synthétisé en utilisant les outils Xilinx ISE Webpack
 (Xst), le code source est en langage Verilog et versionné sur github.
 Une simulation est faite en utilisant le logiciel icarus verilog, les résultats
 de cette simulation sont analysés en utilisant gtkwave qui génère les chronogra
mmes des signaux importants.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/Xilinx_Spartan_3A_Evaluation_Kit_kl.jpg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Plaque de développement 
\begin_inset Quotes eld
\end_inset

AVnet Spartan-3A Evaluation Kit
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Le BUS
\end_layout

\begin_layout Standard
Notre système fonctionne sur 1 seul et unique fil.
 Les appareils communiquent entre-eux en envoyant des signaux logiques sur
 ce fil.
\end_layout

\begin_layout Standard
Afin de ne pas avoir conflit entre les appareils qui pourront communiquer
 sur ce fil, nous avons choisi : 
\end_layout

\begin_layout Standard
Topologie du bus : 1 maitre, plusieurs esclaves.
\end_layout

\begin_layout Standard
Protocole de communication : Questions / Réponses
\end_layout

\begin_layout Section
Structure des couches d'abstractions
\end_layout

\begin_layout Subsection
La couche physique
\end_layout

\begin_layout Subsubsection
Etat logique par défaut
\end_layout

\begin_layout Standard
Par défaut, la ligne sera à un état logique haut (5V).
 Lorsqu'un des appareils voudra communiquer avec un autre, il devra créer
 un front montant pour commencer la communication (donc, passer par un état
 bas avant de repasser par un état haut).
 Ainsi, avant de communiquer, tout appareil n'ayant pas reçu d'interruption
 pendant un certain temps, verifiera que la 
\begin_inset Quotes eld
\end_inset

ligne
\begin_inset Quotes erd
\end_inset

 est à un état logique haut.
 Si ce n'est pas le cas, il attendra avant d'emmettre son signal.
\end_layout

\begin_layout Subsubsection
Définition des bits
\end_layout

\begin_layout Standard
Un bit est un quantum de temps de 10ms (que nous pourrons diminuer plus
 tard).
 Il existe 4 types de bit
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Itemize
Le bit de start
\end_layout

\begin_layout Itemize
Le bit d'un état logique bas
\end_layout

\begin_layout Itemize
Le bit d'un état logique haut
\end_layout

\begin_layout Itemize
Le bit de stop
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-bit.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
De gauche à droite
\begin_inset space ~
\end_inset

: Le bit de start (10ms à l'état bas), suivi du bit représentant l'état
 logique bas, puis celui de l'état logique haut, et enfin, le bit de stop
 (front montant restant à l'état haut).
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Les 4 types de bits possible
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un des objectifs est de ne pas avoir de désynchronisation entres les 2 appareils
 qui communiquent entre eux.
\end_layout

\begin_layout Standard
En effet, supposons que tout les bits fassent 10ms.
 Une trame normal fait 9 bits (1octet + 1 bit de parité).
 Le récepteur va, à partir du premier bit reçu déclencher un timer, et regarder
 régulière le signal pour voir à quel état se trouve celui-ci.
 Cependant, si les 2 systèmes n'ont pas exactement la même fréquence, il
 y aura une désynchronisation des 2 appareils et une perte de bit.
\end_layout

\begin_layout Standard
Afin d'éviter cela, nous avons décidé de resynchroniser nos appareils à
 chaque bit.
 Tous les bits (état logique haut ou bas) commencent par un front montant.
 A partir de ce moment, le récepteur lance un timer.
 Au bout de 5ms (50% du temps du bit), il va regarder l'état du signal (haut
 ou bas) et en déduire l'état du bit.
 Mais au lieu de faire continuer son timer, il va le stopper, et le relancer
 lors de l'arriver du prochain bit par un front montant.
\end_layout

\begin_layout Standard
Pour cela, un état logique haut sera représenté par un état haut de 2/3
 du temps total (soit 7ms) puis d'un état bas pendant 1/3 du temps (3ms).
 Il en va de même pour l'état logique bas, représenté par un état haut de
 1/3 du temps et les 2/3 restant par un état bas.
 Ainsi, la durée du bit est de 10ms, tout les bits commencent par un front
 montant et finissent pas un état bas (permettant de faire un nouveau front
 montant).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-2bits-new.png
	scale 55

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Représentation des état haut et bas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Trame de données
\end_layout

\begin_layout Standard
La trame de données est constituée par une trame de 8 bits contenant un
 octet de données, suivi par 1 bit de parité.
 Cela permet d'avoir une première vérification du signal sur la couche physique.
 En cas d'erreur, celle-ci est transmise à la couche supérieur, qui traitera
 l'erreur.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-octet.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Exemple d'une trame d'un octet (0x42)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
La couche de transport
\end_layout

\begin_layout Standard
La couche de transport nous permet d'avoir un système d'adresse et de vérificati
on du signal.
\end_layout

\begin_layout Subsubsection
L'adressage
\end_layout

\begin_layout Standard
L'adressage se fait sur un octet.
 Lors de la communication entre 2 appareils, le premier transferts correspondra
 à l'adresse de l'appareil source.
 Ensuite, nous transmettrons l'adresse de destination.
\end_layout

\begin_layout Standard
Cela permet de pouvoir s'adresser à un seul et unique appareil.
\end_layout

\begin_layout Subsubsection
La vérification
\end_layout

\begin_layout Standard
Nous avons un octet qui est réservé pour pouvoir transférer des données
 de vérification ainsi que la taille du paquet.
\end_layout

\begin_layout Standard
Les 4 premiers bits de cet octet servent à définir la taille de notre paquet,
 pour pouvoir dire au récepteur combien d'octets de données utiles sont
 transférés.
\end_layout

\begin_layout Standard
Les 4 derniers bits servent de checksum, pour s'assurer qu'il n'y a pas
 d'erreur dans le transfert des données dans le paquet.
\end_layout

\begin_layout Subsubsection
La forme d'un paquet
\end_layout

\begin_layout Standard
Après ces 3 octets, nous transférons un certain nombres de paquets de données
 utiles, qui dépendra de ce que l'émetteur veut envoyer.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Voici la structure d'un paquet
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Enumerate
Un octet contenant l'adresse source
\end_layout

\begin_layout Enumerate
Un octet contenant l'adresse de destination
\end_layout

\begin_layout Enumerate
Un octet de vérification
\begin_inset space ~
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
4 bits indiquant le nombre d'octet de donnée utile à transferer
\end_layout

\begin_layout Itemize
4 bits de checksum sur le paquet total pour éviter d'avoir des erreurs.
\end_layout

\end_deeper
\begin_layout Enumerate
Les octets contenant les données utiles (payload).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="9">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="middle" width="1.5cm">
<column alignment="center" valignment="middle" width="1.5cm">
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="top" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<row>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adresse Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adresse Destination
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taille du paquet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Checksum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Octet(s) de donnée(s)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Structure d'un paquet
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
La couche applicative
\end_layout

\begin_layout Standard
La couche supérieur est la couche applicative.
 C'est celle qui appellera la fonction d'envoie pour l'émetteur, et qui
 sera appelée lorsqu'une interruption arrive, signifiant l'arrivée d'un
 paquet, déjà traité par la couche 2.
\end_layout

\begin_layout Part
Pratique
\end_layout

\begin_layout Chapter
Microcontrôleur
\end_layout

\begin_layout Chapter
FPGA
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\end_body
\end_document
