#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\use_default_options true
\language french
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
PJ
\begin_inset Newline newline
\end_inset

Protocole de communication
\end_layout

\begin_layout Author
\begin_inset VSpace 13cm
\end_inset


\begin_inset Newline newline
\end_inset

Jérémy Cheynet
\begin_inset Newline newline
\end_inset

Yann Sionneau
\end_layout

\begin_layout Date
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename image/logo_SP.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset

Année 2010
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Théorie
\end_layout

\begin_layout Chapter
Objectifs
\end_layout

\begin_layout Standard
L'objectif de notre projet est de créer un système qui permet de faire communiqu
er toutes sortes d'électronique embarquée entre elles.
 Une des conditions que nous nous sommes fixée, est de faire communiquer
 les appareils sur un seul et unique fil pour pouvoir, dans un second temps,
 faire communiquer ces appareils avec une liaison sans fils.
\end_layout

\begin_layout Standard
Les systèmes embarqués que nous comptons utiliser sont des microcontrôleurs
 et des FPGA
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
FPGA
\emph default
 (field-programmable gate array, réseau matriciel de portes logiques programmabl
es ).
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Afin de faciliter la communication entre les appareils, et l'architecture
 de notre système, nous avons choisi d'utiliser une structure sous forme
 de couches d'abstractions (en s'inspirant du model OSI).
\end_layout

\begin_layout Chapter
Spécifictions
\end_layout

\begin_layout Section
Matériel
\end_layout

\begin_layout Standard
Notre choix étant de faire fonctionner notre système sur plusieurs système
 et différente architecture.
 Pour cela, nous avons décidé de développer notre système sur un microctontrôleu
r et sur un FPGA.
 Nous avons donc choisi, parmi la grande gamme de produits disponibles dans
 ces 2 catégorie, une architecture de microcontrôleur et un type de FPGA.
 
\end_layout

\begin_layout Subsection
Microcontrôleur
\end_layout

\begin_layout Standard
Nous avons choisi d'implémenter notre système sur microcontrôleur car ces
 puces électroniques sont très répandues, très utilisées et faciles d'utilisatio
n.
 En effet, utiliser un microprocesseur oblige de rajouter de la mémoire,
 et des modules externe, tandis qu'un microcontrôleur est autonome.
\end_layout

\begin_layout Standard
Le microcontrôleur que nous utilisons fait partie la gamme ATMega (architecture
 AVR) de chez ATMEL.
 Ce type de microcontrôleur est facilement programmable en C/C++, et se
 trouve pour un prix correct.
\end_layout

\begin_layout Standard
Voici les 3 types de microcontrôleurs que nous allons utiliser
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Description
La
\begin_inset space ~
\end_inset

carte
\begin_inset space ~
\end_inset

arduino
\begin_inset space ~
\end_inset

: Il s'agit d'une carte microcontrôleur toute prète, programmable en C/C++
 avec un logiciel fourni gratuitement.
 Tout les programmes et toutes les shields
\begin_inset Foot
status open

\begin_layout Plain Layout
Petite carte électronique que l'on peut facilement brancher sur la carte
 arduino
\end_layout

\end_inset

 sont open-sources.
 Le microcontrôleur qui se trouve sur la carte est un ATMEGA168 de chez
 ATMEL.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/arduino.jpg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Carte Arduino
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Description
L'ATMEGA324
\begin_inset space ~
\end_inset

: Il s'agit d'un microcontrôleur 40 broches de 32 entrées/sorties de chez
 ATMEL.
 La carte que nous utilisons pour l'utiliser est une carte faite maison,
 et programmée grâce au logiciel libre avrdude à l'aide d'un ISP programmer
 (système libre pour programmer la série avr de chez ATMEL).
 Le programme s'effectue toujours en C/C++ et se compile grâce à la toolchain
 GNU pour l'architecture AVR (avr-gcc, avr-objdump, avr-ld, avr-as etc ...).
\end_layout

\begin_layout Description
L'ATTINY13
\begin_inset space ~
\end_inset

: Microcontrôleur à prix réduit de chez ATMEL.
 Il s'agit d'un petit microcontrôleur de 8 broches, programmable comme l'ATMEGA3
24.
 Là aussi, nous allons designer une carte pour pouvoir faire des tests de
 notre système.
\end_layout

\begin_layout Subsection
FPGA
\end_layout

\begin_layout Standard
Nous avons choisi d'utiliser pour nos tests un Spartan-3A 400k portes (XC3S400A)
 de chez Xilinx.
 Cette puce est présente sur la plaque de développement 
\begin_inset Quotes eld
\end_inset

AVnet Spartan-3A Evaluation Kit
\begin_inset Quotes erd
\end_inset

 en notre possession.
 Un port de 40 pins d'entrées/sorties (GPIOs) est disponible sur cette plaque
 que nous pourront utiliser pour tester le protocole, en la reliant par
 exemple à un Arduino.
 Le bitstream est synthétisé en utilisant les outils Xilinx ISE Webpack
 (Xst), le code source est en langage Verilog et versionné sur github.
 Une simulation est faite en utilisant le logiciel icarus verilog, les résultats
 de cette simulation sont analysés en utilisant gtkwave qui génère les chronogra
mmes des signaux importants.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/Xilinx_Spartan_3A_Evaluation_Kit_kl.jpg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Plaque de développement 
\begin_inset Quotes eld
\end_inset

AVnet Spartan-3A Evaluation Kit
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Le BUS
\end_layout

\begin_layout Standard
Notre système fonctionne sur 1 seul et unique fil.
 Les appareils communiquent entre-eux en envoyant des signaux logiques sur
 ce fil.
\end_layout

\begin_layout Standard
Afin de ne pas avoir conflit entre les appareils qui pourront communiquer
 sur ce fil, nous avons choisi : 
\end_layout

\begin_layout Standard
Topologie du bus : 1 maitre, plusieurs esclaves.
\end_layout

\begin_layout Standard
Protocole de communication : Questions / Réponses
\end_layout

\begin_layout Section
Structure des couches d'abstractions
\end_layout

\begin_layout Subsection
La couche physique
\end_layout

\begin_layout Subsubsection
Etat logique par défaut
\end_layout

\begin_layout Standard
Par défaut, la ligne sera à un état logique haut (5V).
 Lorsqu'un des appareils voudra communiquer avec un autre, il devra créer
 un front montant pour commencer la communication (donc, passer par un état
 bas avant de repasser par un état haut).
 Ainsi, avant de communiquer, tout appareil n'ayant pas reçu d'interruption
 pendant un certain temps, verifiera que la 
\begin_inset Quotes eld
\end_inset

ligne
\begin_inset Quotes erd
\end_inset

 est à un état logique haut.
 Si ce n'est pas le cas, il attendra avant d'emmettre son signal.
\end_layout

\begin_layout Subsubsection
Définition des bits
\end_layout

\begin_layout Standard
Un bit est un quantum de temps de 10ms (que nous pourrons diminuer plus
 tard).
 Il existe 4 types de bit
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Itemize
Le bit de start
\end_layout

\begin_layout Itemize
Le bit d'un état logique bas
\end_layout

\begin_layout Itemize
Le bit d'un état logique haut
\end_layout

\begin_layout Itemize
Le bit de stop
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-bit.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
De gauche à droite
\begin_inset space ~
\end_inset

: Le bit de start (10ms à l'état bas), suivi du bit représentant l'état
 logique bas, puis celui de l'état logique haut, et enfin, le bit de stop
 (front montant restant à l'état haut).
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Les 4 types de bits possible
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un des objectifs est de ne pas avoir de désynchronisation entres les 2 appareils
 qui communiquent entre eux.
\end_layout

\begin_layout Standard
En effet, supposons que tout les bits fassent 10ms.
 Une trame normal fait 9 bits (1octet + 1 bit de parité).
 Le récepteur va, à partir du premier bit reçu déclencher un timer, et regarder
 régulière le signal pour voir à quel état se trouve celui-ci.
 Cependant, si les 2 systèmes n'ont pas exactement la même fréquence, il
 y aura une désynchronisation des 2 appareils et une perte de bit.
\end_layout

\begin_layout Standard
Afin d'éviter cela, nous avons décidé de resynchroniser nos appareils à
 chaque bit.
 Tous les bits (état logique haut ou bas) commencent par un front montant.
 A partir de ce moment, le récepteur lance un timer.
 Au bout de 5ms (50% du temps du bit), il va regarder l'état du signal (haut
 ou bas) et en déduire l'état du bit.
 Mais au lieu de faire continuer son timer, il va le stopper, et le relancer
 lors de l'arriver du prochain bit par un front montant.
\end_layout

\begin_layout Standard
Pour cela, un état logique haut sera représenté par un état haut de 2/3
 du temps total (soit 7ms) puis d'un état bas pendant 1/3 du temps (3ms).
 Il en va de même pour l'état logique bas, représenté par un état haut de
 1/3 du temps et les 2/3 restant par un état bas.
 Ainsi, la durée du bit est de 10ms, tout les bits commencent par un front
 montant et finissent pas un état bas (permettant de faire un nouveau front
 montant).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-2bits-new.png
	scale 55

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Représentation des état haut et bas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Trame de données
\end_layout

\begin_layout Standard
La trame de données est constituée par une trame de 8 bits contenant un
 octet de données, suivi par 1 bit de parité.
 Cela permet d'avoir une première vérification du signal sur la couche physique.
 En cas d'erreur, celle-ci est transmise à la couche supérieur, qui traitera
 l'erreur.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-octet.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Exemple d'une trame d'un octet (0x42)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
La couche de transport
\end_layout

\begin_layout Standard
La couche de transport nous permet d'avoir un système d'adresse et de vérificati
on du signal.
\end_layout

\begin_layout Subsubsection
L'adressage
\end_layout

\begin_layout Standard
L'adressage se fait sur un octet.
 Lors de la communication entre 2 appareils, le premier transferts correspondra
 à l'adresse de l'appareil source.
 Ensuite, nous transmettrons l'adresse de destination.
\end_layout

\begin_layout Standard
Cela permet de pouvoir s'adresser à un seul et unique appareil.
\end_layout

\begin_layout Subsubsection
La vérification
\end_layout

\begin_layout Standard
Nous avons un octet qui est réservé pour pouvoir transférer des données
 de vérification ainsi que la taille du paquet.
\end_layout

\begin_layout Standard
Les 4 premiers bits de cet octet servent à définir la taille de notre paquet,
 pour pouvoir dire au récepteur combien d'octets de données utiles sont
 transférés.
\end_layout

\begin_layout Standard
Les 4 derniers bits servent de checksum, pour s'assurer qu'il n'y a pas
 d'erreur dans le transfert des données dans le paquet.
\end_layout

\begin_layout Subsubsection
La forme d'un paquet
\end_layout

\begin_layout Standard
Après ces 3 octets, nous transférons un certain nombres de paquets de données
 utiles, qui dépendra de ce que l'émetteur veut envoyer.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Voici la structure d'un paquet
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Enumerate
Un octet contenant l'adresse source
\end_layout

\begin_layout Enumerate
Un octet contenant l'adresse de destination
\end_layout

\begin_layout Enumerate
Un octet de vérification
\begin_inset space ~
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
4 bits indiquant le nombre d'octet de donnée utile à transferer
\end_layout

\begin_layout Itemize
4 bits de checksum sur le paquet total pour éviter d'avoir des erreurs.
\end_layout

\end_deeper
\begin_layout Enumerate
Les octets contenant les données utiles (payload).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="9">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="middle" width="1.5cm">
<column alignment="center" valignment="middle" width="1.5cm">
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="top" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<row>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adresse Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adresse Destination
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taille du paquet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Checksum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Octet(s) de donnée(s)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Structure d'un paquet
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
La couche applicative
\end_layout

\begin_layout Standard
La couche supérieur est la couche applicative.
 C'est celle qui appellera la fonction d'envoie pour l'émetteur, et qui
 sera appelée lorsqu'une interruption arrive, signifiant l'arrivée d'un
 paquet, déjà traité par la couche 2.
\end_layout

\begin_layout Part
Pratique
\end_layout

\begin_layout Chapter
Microcontrôleur
\end_layout

\begin_layout Section
La couche physique : phy.c et phy.h
\end_layout

\begin_layout Section
La couche d'adressage : mac.c et mac.h
\end_layout

\begin_layout Section
La couche applicative : main.c
\end_layout

\begin_layout Section
Le débogage
\end_layout

\begin_layout Standard
Afin de déboguer notre programme, nous avons mis au point des petits programmes
 de tests qui utilisent la liaison série.
 Ces programmes envoient ou reçoivent des octets, et les renvoient sur la
 liaison série pour pouvoir les afficher sur un ordinateur.
\end_layout

\begin_layout Subsection
La liaison série
\end_layout

\begin_layout Standard
En plus du port série du microcontrôleur ATmega328, la carte arduino (que
 nous avons utilisé pour le développement de notre programme) possède un
 FTDI.
 Celui-ci permet de faire la conversion du signal série TTL en signal série
 RS232.
\end_layout

\begin_layout Standard
Nous avons créé les fonctions qui nous permettent d'émettre sur le port
 série, afin de voir la progression de notre programme.
\end_layout

\begin_layout Standard
Les fonctions que nous avons faites (dont les codes sources se trouvent
 en annexe) permettent d'initialiser la liaison série, de recevoir ou émettre
 un caractère, et d'envoyer un chaine de caractères.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C"
inline false
status open

\begin_layout Plain Layout

void uart_init(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void puts(const char *);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unsigned char uart_recv_char(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void uart_send_char(unsigned char);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
prototype des fonctions utilisant la liaison série
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
uart_init
\end_layout

\begin_layout Standard
La fonction 
\emph on
void uart_init(void)
\emph default
 permet d'initialiser la liaison série à la bonne fréquence
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
La liaison série s'effectue à une fréquence de 9600 bauds.
\end_layout

\end_inset

 en fonction de la fréquence du quartz
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Le quartz de la carte arduino est de 16 MHz.
\end_layout

\end_inset

.
 Le mode de fonctionnement que nous utilisons est le mode polling (pour
 ne pas utiliser de timer).
\end_layout

\begin_layout Subsubsection
uart_send_char
\end_layout

\begin_layout Standard
La fonction 
\emph on
void uart_send_char(unsigned char)
\emph default
 prend en paramètre un octet, et l'envoie par la liaison série.
\end_layout

\begin_layout Subsubsection
puts
\end_layout

\begin_layout Standard
La fonction 
\emph on
void puts(const char *)
\emph default
 prend en paramètre un pointeur vers une chaine de caractère et va utiliser
 la fontion uart_send_char pour envoyer la chaine de caractère
\emph on
.
\begin_inset Newline newline
\end_inset


\begin_inset Box Ovalbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout

\emph on
\begin_inset Graphics
	filename image/attention.gif
	lyxscale 10
	scale 7
	rotateOrigin rightBaseline

\end_inset

Il faut la chaine de caractère donnée à la fonction 
\begin_inset Quotes eld
\end_inset

puts
\begin_inset Quotes erd
\end_inset

 se termine par un 
\begin_inset Quotes eld
\end_inset


\backslash
0
\begin_inset Quotes erd
\end_inset

.
 Dans le cas contraire, la fonction 
\begin_inset Quotes eld
\end_inset

puts
\begin_inset Quotes erd
\end_inset

 lira toute la mémoire jusqu'au reset du microcontroleur.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
uart_recv_char
\end_layout

\begin_layout Standard
La fonction 
\emph on
unsigned char uart_recv_char(void)
\emph default
 permet de recevoir un octet de la liaison série.
\end_layout

\begin_layout Subsection
Les programmes de tests
\end_layout

\begin_layout Subsubsection
Sender
\end_layout

\begin_layout Standard
Afin de tester les fonctions de bases, nous avons fait un programme qui
 émet en boucle un caractère
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Nous émettons le signal 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

#include <avr/io.h>
\end_layout

\begin_layout Plain Layout

#include <avr/interrupt.h>
\end_layout

\begin_layout Plain Layout

#include "usart.h"
\end_layout

\begin_layout Plain Layout

#include "global.h"
\end_layout

\begin_layout Plain Layout

#include "mac.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	while (1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		emissionOctet('@');
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
sender.c
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Receiver
\end_layout

\begin_layout Standard
Toujours dans le cadre du débogage, nous avons fait une fonction qui reçoit
 un caractère par l'intermédiaire de notre protocole, et renvoie ce caractère
 par la liaison série.
 Ainsi, nous pouvons vérifier que nous recevons bien le caractère voulu.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

#include <avr/io.h>
\end_layout

\begin_layout Plain Layout

#include <avr/interrupt.h>
\end_layout

\begin_layout Plain Layout

#include "usart.h"
\end_layout

\begin_layout Plain Layout

#include "global.h"
\end_layout

\begin_layout Plain Layout

#include "mac.h"
\end_layout

\begin_layout Plain Layout

#include "phy.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	uart_init();
\end_layout

\begin_layout Plain Layout

	puts("initialisation...
\backslash
n
\backslash
r");
\end_layout

\begin_layout Plain Layout

	init_mac();
\end_layout

\begin_layout Plain Layout

	puts("MAC layer initialized !
\backslash
n
\backslash
r");
\end_layout

\begin_layout Plain Layout

	while (1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		puts("Received : ");
\end_layout

\begin_layout Plain Layout

		uart_send_char(reception_buffer.src);
\end_layout

\begin_layout Plain Layout

		puts("
\backslash
n
\backslash
r");
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	puts("=FIN=
\backslash
n
\backslash
r");
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
receiver.c
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
FPGA
\end_layout

\begin_layout Part
Annexes
\end_layout

\begin_layout Chapter
Code source microcontrôleur
\end_layout

\begin_layout Section
La liaison série
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

#include <avr/io.h>
\end_layout

\begin_layout Plain Layout

#include <avr/interrupt.h>
\end_layout

\begin_layout Plain Layout

#include "usart.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void puts(const char *string)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	unsigned char i;
\end_layout

\begin_layout Plain Layout

	for (i = 0 ; string[i] != '
\backslash
0' ; i++) 		
\end_layout

\begin_layout Plain Layout

		uart_send_char(string[i]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unsigned char uart_recv_char(void)
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	while ( ! (UCSR0A & (1 << RXC0)) ); 
\end_layout

\begin_layout Plain Layout

		return UDR0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void uart_send_char(unsigned char byte)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	while ( !( UCSR0A & (1<<UDRE0)) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	UDR0 = byte;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void uart_init(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	UBRR0H = (unsigned char)(UBRR >> 8);
\end_layout

\begin_layout Plain Layout

	UBRR0L = (unsigned char)UBRR; 
\end_layout

\begin_layout Plain Layout

	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
\end_layout

\begin_layout Plain Layout

	UCSR0C = (1 << USBS0)|(3<<UCSZ00);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
usart.c
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

#ifndef _USART_H_
\end_layout

\begin_layout Plain Layout

#define _USART_H_
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void uart_init(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void puts(const char *);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unsigned char uart_recv_char(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void uart_send_char(unsigned char);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define FREQ 16000000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define BAUD_RATE 9600
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define UBRR (FREQ/8/BAUD_RATE - 1)/2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
usart.h
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
La couche physique
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
phy.c
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
phy.h
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
La couche d'adressage
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
mac.c
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
mac.h
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
La couche applicative
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
main.c
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Code source FPGA
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\end_body
\end_document
