#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\use_default_options true
\language french
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
PJ
\begin_inset Newline newline
\end_inset

Protocole de communication
\end_layout

\begin_layout Author
\begin_inset VSpace 13cm
\end_inset


\begin_inset Newline newline
\end_inset

Jérémy Cheynet
\begin_inset Newline newline
\end_inset

Yann Sionneau
\end_layout

\begin_layout Date
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename image/logo_SP.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset

Année 2010
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Théorie
\end_layout

\begin_layout Chapter
Objectifs
\end_layout

\begin_layout Standard
L'objectif de notre projet est de créer un système qui permet de faire communiqu
er toutes sortes d'électronique embarquée entre elles.
 Une des conditions que nous nous sommes fixée, est de faire communiquer
 les appareils sur un seul et unique fil pour pouvoir, dans un second temps,
 faire communiquer ces appareils avec une liaison sans fils.
\end_layout

\begin_layout Standard
Les systèmes embarqués que nous comptons utiliser sont des microcontrôleurs
 et des FPGA
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
FPGA
\emph default
 (field-programmable gate array, réseau matriciel de portes logiques programmabl
es ).
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Afin de faciliter la communication entre les appareils et l'architecture
 de notre système, nous avons choisi d'utiliser une structure sous forme
 de couches d'abstractions (en s'inspirant du model OSI).
\end_layout

\begin_layout Chapter
Spécifictions
\end_layout

\begin_layout Section
Matériel
\end_layout

\begin_layout Standard
Notre choix est de faire fonctionner notre protocole sur plusieurs systèmes
 et différentes architectures.
 Pour cela, nous avons décidé d'implémenter notre protocole sur un microctontrôl
eur et sur un FPGA.
 Nous avons donc choisi, parmi la grande gamme de produits disponibles dans
 ces deux catégories, une architecture de microcontrôleur et un type de
 FPGA.
 
\end_layout

\begin_layout Subsection
Microcontrôleur
\end_layout

\begin_layout Standard
Nous avons choisi d'implémenter notre protocole sur microcontrôleur car
 ces puces électroniques sont très répandues, très utilisées et faciles
 d'utilisation.
 En effet, utiliser un microprocesseur oblige de rajouter de la mémoire,
 et des modules externe, tandis qu'un microcontrôleur est autonome.
\end_layout

\begin_layout Standard
Le microcontrôleur que nous utilisons fait partie la gamme ATMega (architecture
 AVR) de chez ATMEL.
 Ce type de microcontrôleur est facilement programmable en C/C++, et se
 trouve pour un prix correct.
\end_layout

\begin_layout Standard
Voici les 3 types de microcontrôleurs que nous allons utiliser
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Description
La
\begin_inset space ~
\end_inset

carte
\begin_inset space ~
\end_inset

arduino
\begin_inset space ~
\end_inset

: Il s'agit d'une carte microcontrôleur toute prète, programmable en C/C++
 avec un logiciel fourni gratuitement.
 Tous les programmes et tous les shields
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Petite carte électronique que l'on peut facilement brancher sur la carte
 arduino
\end_layout

\end_inset

 sont open-source.
 Le microcontrôleur qui se trouve sur la carte est un ATMEGA328p de chez
 ATMEL.
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/arduino.jpg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Carte Arduino
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Description
L'ATMEGA324
\begin_inset space ~
\end_inset

: Il s'agit d'un microcontrôleur 40 broches de 32 entrées/sorties de chez
 ATMEL.
 La carte que nous utilisons pour l'utiliser est une carte faite maison,
 et programmée grâce au logiciel libre avrdude à l'aide d'un ISP programmer
 (système libre pour programmer la série avr de chez ATMEL).
 Le programme s'effectue toujours en C/C++ et se compile grâce à la toolchain
 GNU pour l'architecture AVR (avr-gcc, avr-objdump, avr-ld, avr-as etc ...).
\end_layout

\begin_layout Description
L'ATTINY13
\begin_inset space ~
\end_inset

: Microcontrôleur à prix réduit de chez ATMEL.
 Il s'agit d'un petit microcontrôleur de 8 broches, programmable comme l'ATMEGA3
24.
 Là aussi, nous allons designer une carte pour pouvoir faire des tests de
 notre système.
\end_layout

\begin_layout Subsection
FPGA
\end_layout

\begin_layout Standard
Nous avons choisi d'utiliser pour nos tests un Spartan-3A 400k portes (XC3S400A)
 de chez Xilinx.
 Cette puce est présente sur la plaque de développement 
\begin_inset Quotes eld
\end_inset

AVnet Spartan-3A Evaluation Kit
\begin_inset Quotes erd
\end_inset

 en notre possession.
 Un port de 40 pins d'entrées/sorties (GPIOs) est disponible sur cette plaque
 que nous pourront utiliser pour tester le protocole, en la reliant par
 exemple à un Arduino.
 Le bitstream est synthétisé en utilisant les outils Xilinx ISE Webpack
 (Xst), le code source est en langage Verilog et versionné sur github.
 Une simulation est faite en utilisant le logiciel icarus verilog, les résultats
 de cette simulation sont analysés en utilisant gtkwave qui génère les chronogra
mmes des signaux importants.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/Xilinx_Spartan_3A_Evaluation_Kit_kl.jpg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Plaque de développement 
\begin_inset Quotes eld
\end_inset

AVnet Spartan-3A Evaluation Kit
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Le BUS
\end_layout

\begin_layout Standard
Notre système fonctionne sur 1 seul et unique fil.
 Les appareils communiquent entre-eux en envoyant des signaux logiques sur
 ce fil.
\end_layout

\begin_layout Standard
Afin de ne pas avoir de conflits entre les appareils qui pourront communiquer
 sur ce fil, nous avons choisi : 
\end_layout

\begin_layout Standard
Topologie du bus : 1 maitre, plusieurs esclaves.
\end_layout

\begin_layout Standard
Protocole de communication : Questions / Réponses
\end_layout

\begin_layout Section
Structure des couches d'abstractions
\end_layout

\begin_layout Subsection
La couche physique
\end_layout

\begin_layout Subsubsection
Etat logique par défaut
\end_layout

\begin_layout Standard
Par défaut, la ligne sera à un état logique haut (5V).
 Lorsqu'un des appareils voudra communiquer avec un autre, il devra créer
 un front montant pour commencer la communication (donc, passer par un état
 bas avant de repasser par un état haut).
 Ainsi, avant de communiquer, tout appareil n'ayant pas reçu d'interruption
 pendant un certain temps, verifiera que la 
\begin_inset Quotes eld
\end_inset

ligne
\begin_inset Quotes erd
\end_inset

 est à un état logique haut.
 Si ce n'est pas le cas, il attendra avant d'émettre son signal.
\end_layout

\begin_layout Subsubsection
Définition des bits
\end_layout

\begin_layout Standard
Un bit est un quantum de temps de 10ms (que nous pourrons diminuer plus
 tard).
 Il existe 4 types de bit
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Itemize
Le bit de start
\end_layout

\begin_layout Itemize
Le bit d'un état logique bas
\end_layout

\begin_layout Itemize
Le bit d'un état logique haut
\end_layout

\begin_layout Itemize
Le bit de stop
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-bit.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
De gauche à droite
\begin_inset space ~
\end_inset

: Le bit de start (10ms à l'état bas), suivi du bit représentant l'état
 logique bas, puis celui de l'état logique haut, et enfin, le bit de stop
 (front montant restant à l'état haut).
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Les 4 types de bits possible
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un des objectifs est de ne pas avoir de désynchronisation entres les 2 appareils
 qui communiquent entre eux.
\end_layout

\begin_layout Standard
En effet, supposons que tous les bits fassent 10ms.
 Une trame normal fait 11 bits (1octet + 1 bit de parité + 1 bit de start
 + 1 bit de stop).
 Le récepteur va, à partir du premier bit reçu déclencher un timer, et regarder
 régulière le signal pour voir à quel état se trouve celui-ci.
 Cependant, si les 2 systèmes n'ont pas exactement la même fréquence, il
 y aura une désynchronisation des 2 appareils et une perte de bit.
\end_layout

\begin_layout Standard
Afin d'éviter cela, nous avons décidé de resynchroniser nos appareils à
 chaque bit.
 Tous les bits (état logique haut ou bas) commencent par un front montant.
 A partir de ce moment, le récepteur lance un timer.
 Au bout de 5ms (50% du temps du bit), il va regarder l'état du signal (haut
 ou bas) et en déduire l'état du bit.
 Mais au lieu de faire continuer son timer, il va le stopper, et le relancer
 lors de l'arriver du prochain bit par un front montant.
\end_layout

\begin_layout Standard
Pour cela, un état logique haut sera représenté par un état haut de 2/3
 du temps total (soit 7ms) puis d'un état bas pendant 1/3 du temps (3ms).
 Il en va de même pour l'état logique bas, représenté par un état haut de
 1/3 du temps et les 2/3 restant par un état bas.
 Ainsi, la durée du bit est de 10ms, tout les bits commencent par un front
 montant et finissent pas un état bas (permettant de faire un nouveau front
 montant).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-2bits-new.png
	scale 55

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Représentation des état haut et bas
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Trame de données
\end_layout

\begin_layout Standard
La trame de données est constituée par une trame de 8 bits contenant un
 octet de données, suivi par 1 bit de parité.
 Cela permet d'avoir une première vérification du signal sur la couche physique.
 En cas d'erreur, celle-ci est transmise à la couche supérieur, qui traitera
 l'erreur.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename image/chronogramme-octet.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Exemple d'une trame d'un octet (0x42)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
La couche de transport
\end_layout

\begin_layout Standard
La couche de transport nous permet d'avoir un système d'adresse et de vérificati
on du signal.
\end_layout

\begin_layout Subsubsection
L'adressage
\end_layout

\begin_layout Standard
L'adressage se fait sur un octet.
 Lors de la communication entre 2 appareils, le premier transferts correspondra
 à l'adresse de l'appareil source.
 Ensuite, nous transmettrons l'adresse de destination.
\end_layout

\begin_layout Standard
Cela permet de pouvoir s'adresser à un seul et unique appareil.
\end_layout

\begin_layout Subsubsection
La vérification
\end_layout

\begin_layout Standard
Nous avons un octet qui est réservé pour pouvoir transférer des données
 de vérification ainsi que la taille du paquet.
\end_layout

\begin_layout Standard
Les 4 premiers bits de cet octet servent à définir la taille de notre paquet,
 pour pouvoir dire au récepteur combien d'octets de données utiles sont
 transférés.
\end_layout

\begin_layout Standard
Les 4 derniers bits servent de checksum, pour s'assurer qu'il n'y a pas
 d'erreur dans le transfert des données dans le paquet.
\end_layout

\begin_layout Subsubsection
La forme d'un paquet
\end_layout

\begin_layout Standard
Après ces 3 octets, nous transférons un certain nombre de paquets de données
 utiles, qui dépendra de ce que l'émetteur veut envoyer.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Voici la structure d'un paquet
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Enumerate
Un octet contenant l'adresse source
\end_layout

\begin_layout Enumerate
Un octet contenant l'adresse de destination
\end_layout

\begin_layout Enumerate
Un octet de vérification
\begin_inset space ~
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
4 bits indiquant le nombre d'octet de donnée utile à transferer
\end_layout

\begin_layout Itemize
4 bits de checksum sur le paquet total pour éviter d'avoir des erreurs.
\end_layout

\end_deeper
\begin_layout Enumerate
Les octets contenant les données utiles (payload).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="9">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="middle" width="1.5cm">
<column alignment="center" valignment="middle" width="1.5cm">
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="top" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<column alignment="center" valignment="middle" width="0.05cm">
<row>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adresse Source
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adresse Destination
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Taille du paquet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Checksum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Octet(s) de donnée(s)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Structure d'un paquet
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
La couche applicative
\end_layout

\begin_layout Standard
La couche supérieur est la couche applicative.
 C'est celle qui appellera la fonction d'envoie pour l'émetteur, et qui
 sera appelée lorsqu'une interruption arrive, signifiant l'arrivée d'un
 paquet, déjà traité par la couche 2.
\end_layout

\begin_layout Part
Implémentation
\end_layout

\begin_layout Chapter
Microcontrôleur
\end_layout

\begin_layout Section
La couche physique : phy.c et phy.h
\end_layout

\begin_layout Standard
Nous allons commencer par essayer de comprendre comment fonctionne la couche
 la plus bas niveau
\begin_inset space ~
\end_inset

: la couche physique.
 
\end_layout

\begin_layout Standard
Anfin de savoir comment fonction cette couche, nous avons l'algorithme 3.1
 qui nous indique la liste des fonctions disponibles dans ces fichiers.
 De plus, nous allons étudier le fonctionnement des fonctions les plus important
es.
 Pour de plus amples détails, il est conseillé de se reporter au code source
 disponible en annexe qui est commenté.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C"
inline false
status open

\begin_layout Plain Layout

void relancerTimer(uint16_t valeur);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void initTimer(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void emissionOctet( uint8_t octet);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void envoieHaut( void );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void envoieBas( void );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void pause(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void depart(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint8_t xor( uint8_t octet );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint8_t sample(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void stop_timer();
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Prototypes des fonctions de phy.c
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Réception d'un octet
\end_layout

\begin_layout Standard
Afin de recevoir un octet, sans avoir de système bloquant, nous utilisons
 les interruptions du microcontrôleur.
 La première interruption est l'interruption de front montant qui signale
 l'arrivé d'un bit transmis.
 La seconde interruption est celle du timer 1 qui permet de mesure le temps
 pour pouvoir analyser le bit reçu au bon moment.
\end_layout

\begin_layout Subsubsection
Interruption sur front montant de la pin PD5
\end_layout

\begin_layout Standard
Le vecteur d'interruption de front montant sur PCINT0 
\emph on
ISR(INT0_vect)
\emph default
 permet de détecter l'arrivée d'un bit, même si le programme principal ne
 nous donne pas la main.
 Lors de la gestion de cette interruption, nous allons lancer le timer pour
 que celui-ci provoque une interruption 1ms après l'arrivée du bit.
\end_layout

\begin_layout Subsubsection
Interruption du timer1
\end_layout

\begin_layout Standard
En cas d'arrivée d'une interruption du au timer 1 (lancé par l'arrivé d'un
 bit), nous allons vérifier que le temps nécessaire c'est bien écoulé, et
 enregistrer chaque bit reçu de manière à pouvoir envoyer un octet entier
 à la couche supérieur.
\end_layout

\begin_layout Description
Réception
\begin_inset space ~
\end_inset

d'un
\begin_inset space ~
\end_inset

bit
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

start
\begin_inset space ~
\end_inset

: Le première chose que l'on va faire lors de cette routine d'interruption,
 et de vérifier que nous ayons bien reçu un bit de start.
 Si nous avons bien reçu un bit de start, nous incrémentons un compteur
 qui nous indique le numéro du prochain bit que l'on va recevoir et nous
 prenons le mutex de ligne afin de ne pas émettre tant que nous n'avons
 pas reçu un octet en entier.
 Puis nous quittons la routine d'interruption.
 Dans le cas contraire, nous quittons la routine d'interruption en continuant
 d'attendre un bit de start.
\end_layout

\begin_layout Description
Réception
\begin_inset space ~
\end_inset

du
\begin_inset space ~
\end_inset

bit
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

stop
\begin_inset space ~
\end_inset

: Cela peut paraitre bizarre, mais après avoir reçu le bit de start, on
 va vérifier que nous ne recevons pas un bit de stop.
 Si nous avons un bit de stop, on libère le mutex de ligne, et on quitte
 l'interruption après avoir réinitialisé les variables locales.
 Le fait de vérifier le bit de stop avant les bits de données permet de
 gagner du temps dans les routines d'interruptions (puisque nous les quittons
 plus tôt) et donc laisser le temps processeur au programme principal.
\end_layout

\begin_layout Description
Réception
\begin_inset space ~
\end_inset

des
\begin_inset space ~
\end_inset

bits
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

donnée
\begin_inset space ~
\end_inset

: Enfin, nous allons enregistrer les neufs bits suivants
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
8 bits de données et 1 bit de parité
\end_layout

\end_inset

.
 Cette opération se fait en 2 temps.
\end_layout

\begin_deeper
\begin_layout Description
Réception
\begin_inset space ~
\end_inset

des
\begin_inset space ~
\end_inset

données
\begin_inset space ~
\end_inset

: Tout d'abord, nous enregistrons les 8 premiers bits reçu puisqu'il s'agit
 de l'octet que l'on veut recevoir.
\end_layout

\begin_layout Description
Réception
\begin_inset space ~
\end_inset

du
\begin_inset space ~
\end_inset

bit
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

parité
\begin_inset space ~
\end_inset

: Puis nous enregistrons le neuvième bit qui correspond au bit de parité.
 C'est à ce moment là que l'on appel la couche supérieur avec soit, l'envoi
 de l'octet reçu si la parité reçue et calculée sont identique, ou l'appel
 à une fonction de gestion des erreurs dans le cas contraire.
 
\end_layout

\end_deeper
\begin_layout Subsection
Emission d'un octet
\end_layout

\begin_layout Standard
Pour envoyer 1 octet, nous avons une fonction bloquante (
\emph on
void emissionOctet( uint8_t octet)
\emph default
)qui prend un octet en paramètre, et qui s'occupe de faire appel aux fonctions
 très bas niveau qui envoie un bit logique 
\begin_inset Quotes eld
\end_inset

haut
\begin_inset Quotes erd
\end_inset

 ou un bit logique 
\begin_inset Quotes eld
\end_inset

bas
\begin_inset Quotes erd
\end_inset

.
 Cette fonction fait un appel à la fonction de calcul de parité pour envoyer
 la parité après les données.
\begin_inset Newline newline
\end_inset

Cette fonction va d'abord vérifier que la ligne est libre (à l'aide du mutex
 de ligne), puis envoyer un bit de start suivi des données, de la parité
 et enfin le bit de stop qui remet la ligne à l'état (idle) logique haut
 (5V).
\end_layout

\begin_layout Subsubsection
Envoi d'un bit logique 
\begin_inset Quotes eld
\end_inset

haut
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
La fonction 
\emph on
void envoieHaut( void )
\emph default
 se contente d'envoyer un bit logique 
\begin_inset Quotes eld
\end_inset

haut
\begin_inset Quotes erd
\end_inset

 en envoyant un état logique haut (5V) pendant 7ms puis un état logique
 bas (0V) pendant 3ms.
\end_layout

\begin_layout Subsubsection
Envoi d'un bit logique 
\begin_inset Quotes eld
\end_inset

bas
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
La fonction 
\emph on
void envoieBas( void )
\emph default
 fait la même chose que la fonction précédente, sauf qu'elle envoie un bit
 logique 
\begin_inset Quotes eld
\end_inset

bas
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Calcul de la parité
\end_layout

\begin_layout Standard
Un fonction de calcul de parité 
\emph on
uint8_t xor( uint8_t octet )
\emph default
 prend en paramètre un octet, calcul la valeur de la parité qui lui est
 associée, et renvoie un octet
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
il n'est pas possible de définir un bit en langage C avr
\end_layout

\end_inset

 qui vaut soit 0 soit 1.
\end_layout

\begin_layout Section
La couche d'adressage : mac.c et mac.h
\end_layout

\begin_layout Standard
Maintenant que nous savons comment fonctionne la couche physique, nous allonc
 voir comment la couche 2 (la couche de transport) traite les données reçues
 par la couche physique, et prépare les paquets et les stocke avant une
 utilisation de ces données par la couche applicative.
\end_layout

\begin_layout Standard
Comme pour la couche physique, nous avons une liste des prototypes de fonctions
 existante, mais nous n'étudierons que le système global avec les fonctions
 les plus importantes.
 Pour de plus amples informations, se reporter au code source.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C"
inline false
status open

\begin_layout Plain Layout

void init_mac(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void push_byte(unsigned char);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void clear_ring_buffer_overflow(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void copy_packet_to_rx_ring(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void send( uint8_t address_dest, uint8_t data[16], uint8_t taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int8_t recv (uint8_t *src, uint8_t *taille, unsigned char *datas);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint8_t calcul_checksum( uint8_t data[16], uint8_t taille);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unsigned char rx_buffer_overflow(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint8_t can_write(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

uint8_t can_read(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void inc_write_pointer(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void inc_read_pointer(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

inline void clear_ring_buffer_overflow(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void detection_erreur( uint8_t erreur);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Prototype des fonctions de mac.c
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Réception d'un paquet
\end_layout

\begin_layout Standard
Pour que l'application puisse recevoir les données d'un paquet, il faut
 créer ce paquet et traiter toutes les données reçues.
 Cela se fait en 3 grandes étapes que nous allons voir.
\end_layout

\begin_layout Subsubsection
Réception d'un octet de la couche physique
\end_layout

\begin_layout Standard
La première étape correspond à la fonction 
\emph on
void push_byte(unsigned char b)
\emph default
 qui est appelé par la couche physique lorsque celle-ci a reçu un octet.
 C'est cette fonction qui va constituer le paquet.
 Pour ce faire, nous utilisons un compteur qui permet de connaitre le numéro
 de l'octet reçu.
 C'est à partir de ce compteur que tout se fait, comme suit
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Description
Est-ce
\begin_inset space ~
\end_inset

le
\begin_inset space ~
\end_inset

dernier
\begin_inset space ~
\end_inset

octet
\begin_inset space ~
\end_inset

: On va d'abord vérifier que le numéro de l'octet reçu vaut soit la taille
 du paquet que l'on doit recevoir, soit la taille maximale du paquet.
 Si c'est le cas, on va stocker le paquet local
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Nous avons définit une structure paquet
\end_layout

\end_inset

 que l'on a créé dans le buffer circulaire partagé entre la couche 2 et
 la couche applicative.
 Enfin, on va réinitialiser toutes les variables locales et le compteur.
\end_layout

\begin_layout Description
Octet
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

data
\begin_inset space ~
\end_inset

: Si l'octet que l'on reçoit n'est pas le dernier octet, on va constituer
 le début de notre paquet.
\end_layout

\begin_deeper
\begin_layout Description
Avons
\begin_inset space ~
\end_inset

nous
\begin_inset space ~
\end_inset

un
\begin_inset space ~
\end_inset

octet
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

start
\begin_inset space ~
\end_inset

: On va d'abord vérifier que l'on a un octet de start
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
L'octet de start permet d'éviter une désynchronisation de paquet
\end_layout

\end_inset

 qui est aussi l'octet correspondant à l'adresse source.
 Si ce n'est pas le cas, on retourne et on attend un octet de start.
 Si c'est bien le bon octet, on le stocke dans notre structure paquet, dans
 la partie source, puis on incrémente notre compteur pour signaler que l'on
 attend un octet correspondant à l'adresse de destination.
\end_layout

\begin_layout Description
Adresse
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

destination
\begin_inset space ~
\end_inset

: L'octet suivant est enregistré directement sans traitement.
 Il s'agit de l'adresse de destination.
\end_layout

\begin_layout Description
Checksum
\begin_inset space ~
\end_inset

et
\begin_inset space ~
\end_inset

taille
\begin_inset space ~
\end_inset

: L'octet suivant est le checksum du paquet et la taille des données.
 Le checksum est enregistré, tandis que la taille sera utilisée pour savoir
 combien d'octets de données nous allons enregistrer pour finir de créer
 notre paquet.
\end_layout

\begin_layout Description
Data
\begin_inset space ~
\end_inset

: La suite correspond aux données utiles (payload).
 On va utiliser la taille du paquet reçu précédemment afin de savoir combien
 d'octets enregistrer.
\end_layout

\end_deeper
\begin_layout Subsubsection
Le buffer circulaire
\end_layout

\begin_layout Standard
Lorsque un paquet est entièrement reçu par la fonction que nous avons vu
 précédement, le paquet est envoyé dans le buffer circulaire grâce à la
 fonction 
\emph on
void copy_packet_to_rx_ring(void)
\emph default
.
\end_layout

\begin_layout Standard
Cette fonction va, avant de mettre le paquet dans le buffer, vérifier quelques
 paramètres
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Itemize
Vérifier que ce paquet nous est bien destiné en comparant l'adresse de destinati
on et l'adresse du programme.
\end_layout

\begin_layout Itemize
Vérifier que le paquet n'est pas erroné en calculant le checksum du paquet,
 et en le comparant avec celui contenu dans le paquet.
\end_layout

\begin_layout Itemize
Vérifier que le buffer n'est pas plein pour ne pas effacer des paquets que
 l'application n'aurait pas encore lu.
\end_layout

\begin_layout Standard
Si une de ces conditions n'est pas vérifiée, le paquet est supprimé et la
 fonction de gestion des erreurs est appelées pour signaler à l'utilisateur
 qu'une erreur s'est produite et qu'un paquet a été supprimé.
\end_layout

\begin_layout Standard
En revanche, si tout s'est bien passé, on stocke le paquet dans le buffer.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Afin d'éviter de supprimer des paquets que l'application n'aurait pas lu,
 et de savoir où lire et où écrire, nous avons des pointeurs de lecture
 et d'écriture sur ce ring buffer.
 Une comparaison de ces 2 pointeurs, en fonction de l'overflow (qui indique
 si nous avons fait un tour complet ou non du buffer), nous permet de savoir
 où écrire et où lire.
\end_layout

\begin_layout Subsubsection
Lecture d'un paquet depuis la couche applicative
\end_layout

\begin_layout Standard
La fonction 
\emph on
uint8_t recv (uint8_t *src, uint8_t *taille, unsigned char *datas)
\emph default
 peut-être appelée par la couche applicative pour lire un paquet reçu depuis
 le buffer circulaire de réception.
\end_layout

\begin_layout Standard
Cette fonction est une fonction bloquante
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Nous avons fait le choix de faire une fonction bloquante pour éviter de
 se retrouver dans la situation suivante
\begin_inset space ~
\end_inset

: Je lis un paquet avec une fonction non bloquante, et je passe à la suite
 du programme.
 J'utilise mon paquet dans la suite du programme.
 Cependant, ma fonction non bloquante n'a pas eu le temps de récupérer le
 paquet.
 Donc le reste du programme s'exécutera avec de fausse valeur.
\end_layout

\end_inset

.
 En revanche, en cas d'erreur détectée (checksum, parité, ...), on débloque
 la fonction.
\end_layout

\begin_layout Standard
Cette fonction renvoie un code retour positif si tout s'est bien passé,
 et un code retour négatif en cas d'erreur de détection.
 Ce code retour permet d'éviter de croire que tout s'est bien déroulé, mais
 avoir retourné des pointeurs vides, ce qui peut être très problématique
 pour la suite du programme.
 
\end_layout

\begin_layout Subsection
Emission d'un paquet
\end_layout

\begin_layout Standard
Lorsque la couche applicative veut envoyer un paquet, il lui suffit d'appeler
 la fonction 
\emph on
void send( uint8_t address_dest, uint8_t data[16], uint8_t taille)
\emph default
 en lui indiquant à qui envoyer le paquet, sa taille et les données.
\end_layout

\begin_layout Standard
Cette fonction rempliera automatiquement l'adresse source et le checksum.
\end_layout

\begin_layout Subsection
Fonctions globales
\end_layout

\begin_layout Subsubsection
Calcul du checksum
\end_layout

\begin_layout Standard
La fonction 
\emph on
uint8_t calcul_checksum( uint8_t data[16], uint8_t taille)
\emph default
 calcul le checksum et renvoie la valeur du checksum.
 Elle est utilisée lors de l'envoie et lors de la réception d'un paquet.
\end_layout

\begin_layout Standard
A l'heure actuelle, cette fonction n'est pas optimisée pour détecter ou
 corriger les erreurs.
 En effet, il est possible que 2 erreurs se compensent.
 Cependant, elle fonctionne très bien pour détecter une erreur sur plusieurs
 bits en fonction de leurs positions dans les données.
\end_layout

\begin_layout Subsubsection
Gestion des erreurs
\end_layout

\begin_layout Standard
Une fonction de gestion des erreurs appelée 
\emph on
void detection_erreur( uint8_t erreur)
\emph default
 a été implémentée.
 Elle est appelée en cas d'erreur quelconque lors de la réception de données.
 Les erreurs peuvent être une erreur dans la parité, dans le checksum ou
 dans la taille du buffer qui peut être rempli.
 Dans ce cas, en fonction du type d'erreur, elle affichera un message différent,
 et débloquera la fonction 
\emph on
recv()
\emph default
 avec un code retour d'erreur.
\end_layout

\begin_layout Section
La couche applicative : main.c
\end_layout

\begin_layout Subsection
Utilisation de notre code
\end_layout

\begin_layout Subsection
Ressources utilisées
\end_layout

\begin_layout Section
Le débogage
\end_layout

\begin_layout Standard
Afin de déboguer notre programme, nous avons mis au point des petits programmes
 de tests qui utilisent la liaison série.
 Ces programmes envoient ou reçoivent des octets, et les renvoient sur la
 liaison série pour pouvoir les afficher sur un ordinateur.
\end_layout

\begin_layout Subsection
La liaison série
\end_layout

\begin_layout Standard
En plus du port série du microcontrôleur ATmega328p, la carte arduino (que
 nous avons utilisé pour le développement de notre programme) possède un
 FTDI.
 Celui-ci permet de faire la conversion du signal série TTL en signal série
 RS232 puis de l'envoyer ensuite sur de l'USB en étant reconnu par GNU/Linux
 et Windows comme une console série (over USB).
\end_layout

\begin_layout Standard
Nous avons créé les fonctions qui nous permettent d'émettre sur le port
 série, afin de voir la progression de notre programme.
\end_layout

\begin_layout Standard
Les fonctions que nous avons faites (dont les codes sources se trouvent
 en annexe) permettent d'initialiser la liaison série, de recevoir ou émettre
 un caractère, et d'envoyer une chaine de caractères.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C"
inline false
status open

\begin_layout Plain Layout

void uart_init(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void puts(const char *);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unsigned char uart_recv_char(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void uart_send_char(unsigned char);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
prototype des fonctions utilisant la liaison série
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
uart_init
\end_layout

\begin_layout Standard
La fonction 
\emph on
void uart_init(void)
\emph default
 permet d'initialiser la liaison série à la bonne fréquence
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
La liaison série s'effectue à une fréquence de 9600 bauds.
\end_layout

\end_inset

 en fonction de la fréquence du quartz
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Le quartz de la carte arduino est de 16 MHz.
\end_layout

\end_inset

.
 Le mode de fonctionnement que nous utilisons est le mode polling (pour
 ne pas utiliser de timer).
\end_layout

\begin_layout Subsubsection
uart_send_char
\end_layout

\begin_layout Standard
La fonction 
\emph on
void uart_send_char(unsigned char)
\emph default
 prend en paramètre un octet, et l'envoie par la liaison série.
\end_layout

\begin_layout Subsubsection
puts
\end_layout

\begin_layout Standard
La fonction 
\emph on
void puts(const char *)
\emph default
 prend en paramètre un pointeur vers une chaine de caractère à zéro terminal
 et va utiliser la fontion uart_send_char pour envoyer la chaine caractère
 par caractère
\emph on
.
\end_layout

\begin_layout Subsubsection
uart_recv_char
\end_layout

\begin_layout Standard
La fonction 
\emph on
unsigned char uart_recv_char(void)
\emph default
 permet de recevoir un octet de la liaison série.
\end_layout

\begin_layout Subsection
Les programmes de tests
\end_layout

\begin_layout Subsubsection
Sender
\end_layout

\begin_layout Standard
Afin de tester les fonctions de base, nous avons fait un programme qui émet
 en boucle un caractère
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Nous émettons le signal 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

#include <avr/io.h>
\end_layout

\begin_layout Plain Layout

#include <avr/interrupt.h>
\end_layout

\begin_layout Plain Layout

#include "usart.h"
\end_layout

\begin_layout Plain Layout

#include "global.h"
\end_layout

\begin_layout Plain Layout

#include "mac.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	while (1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		emissionOctet('@');
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
sender.c
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Receiver
\end_layout

\begin_layout Standard
Toujours dans le cadre du débogage, nous avons fait une fonction qui reçoit
 un caractère par l'intermédiaire de notre protocole, et renvoie ce caractère
 par la liaison série.
 Ainsi, nous pouvons vérifier que nous recevons bien le caractère voulu.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

#include <avr/io.h>
\end_layout

\begin_layout Plain Layout

#include <avr/interrupt.h>
\end_layout

\begin_layout Plain Layout

#include "usart.h"
\end_layout

\begin_layout Plain Layout

#include "global.h"
\end_layout

\begin_layout Plain Layout

#include "mac.h"
\end_layout

\begin_layout Plain Layout

#include "phy.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	uart_init();
\end_layout

\begin_layout Plain Layout

	puts("initialisation...
\backslash
n
\backslash
r");
\end_layout

\begin_layout Plain Layout

	init_mac();
\end_layout

\begin_layout Plain Layout

	puts("MAC layer initialized !
\backslash
n
\backslash
r");
\end_layout

\begin_layout Plain Layout

	while (1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		puts("Received : ");
\end_layout

\begin_layout Plain Layout

		uart_send_char(reception_buffer.src);
\end_layout

\begin_layout Plain Layout

		puts("
\backslash
n
\backslash
r");
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	puts("=FIN=
\backslash
n
\backslash
r");
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
receiver.c
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
FPGA
\end_layout

\begin_layout Part
Résultat, problème et analyse
\end_layout

\begin_layout Chapter
Les problèmes qui sont apparus
\end_layout

\begin_layout Section
Le compilateur
\end_layout

\begin_layout Standard
Ci dessus, je vais écrire deux bouts de code qui font presque la même chose.
 D'après vous quelle est la différence entre ces 2 bouts de code ?
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

while(1)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	uart_send_char('"');
\end_layout

\begin_layout Plain Layout

	if (has_been_received)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		uart_send_char(received_byte);
\end_layout

\begin_layout Plain Layout

		has_been_received = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		emissionOctet('@');
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erreur compilateur 1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
et
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language={C++},numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

while(1)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (has_been_received)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		uart_send_char(received_byte);
\end_layout

\begin_layout Plain Layout

		has_been_received = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		emissionOctet('@');
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Erreur compilateur 2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Comme vous pouvez le voir, ces 2 bouts de codes, qui sont la boucle principale
 du programme main font pratiquement la même chose.
\end_layout

\begin_layout Standard
Le premier va envoyer un caractère sur la liaison série
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Il va envoyer le caractère 
\begin_inset Quotes eld
\end_inset

.
\end_layout

\end_inset

.
 Ensuite, il va vérifier la valeur de la variable globale 
\emph on
has_been_received
\emph default
.
 Si celle-ci vaut 1
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Cette variable est remise à 1 lors par interruption lors de la réception
 d'un octet.
\end_layout

\end_inset

, on remet la variable à 0, et on affiche l'octet que nous avons reçu.
 Sinon, on envoie le caractère 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Dans le second, on fait la même chose, si ce n'est que l'on n'affiche pas
 le caractère 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Et bien la différence entre ces 2 programmes, c'est que le premier fonctionne
 très bien, et affiche les caractères reçus, tandis que le second n'affiche
 absolument pas le caractère reçu, alors que les interruptions nous montrent
 bien que l'on a reçu le caractère en question.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'erreur viens de la compilation.
 Compiler le programme avec l'option d'optimisation d'avr-gcc (-O2) fait
 que le programme 2 ne fonctionne pas.
 Sans cette option (avec simplement -O0 ou rien du tout), le second programme
 fonctionne très bien.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Malheureusement pour nous, nous avions rajouté l'option d'optimisation de
 la compilation pour éviter d'avoir des 
\emph on
warnings
\emph default
 lors de la compilation de la librairie 
\emph on
delay
\emph default
.
 Nous avons ainsi perdu beaucoup de temps à chercher d'où provenait cette
 erreur assez incompréhensible.
 On n'arrivait pas à savoir d'où elle venait.
\end_layout

\begin_layout Standard
Ce n'est que plus tard, au restaurant avec un ancien élève du club de robotique
 de l'école (David Coutherut), en discutant de ce problème que nous avons
 appris le pourquoi du comment.
 Avec l'optimisation lors de la compilation, le test sera effectué lors
 du premier passage dans le if.
 Pour les suivants, il va utiliser le résultat qu'il a déjà, et donc, ne
 va pas aller vérifier si la variable a changé ou non.
 Pour éviter d'avoir ce problème, il aurait fallu que l'on rajoute l'option
 
\emph on
volatile
\emph default
 devant la définition de notre variable.
 Il s'agit en fait de forcer à lire et à écrire directement en mémoire RAM
 en by-passant la mémoire cache du System-on-Chip AVR, seulement nous pensions
 que l'AVR n'avait pas de mémoire cache, erreur !
\end_layout

\begin_layout Section
La désynchronisation
\end_layout

\begin_layout Subsection
Problème de lecture d'un octet
\end_layout

\begin_layout Standard
Lors des tests que nous avons effectué, nous nous sommes rendu compte qu'il
 y avait un problème lors de la réception.
 En effet, nous envoyions le caractère
\begin_inset Quotes erd
\end_inset

@
\begin_inset Quotes erd
\end_inset

, et nous recevions un caractère totalement différent.
 Le plus troublant, c'est que parfois, notre programme foncionnait très
 bien.
\end_layout

\begin_layout Standard
Après des nombreuses recherches pour savoir pourquoi, nous nous sommes rendu
 compte qu'il y avait une désynchronisation entre les bits envoyés et ceux
 que nous recevions.
 En effet, si j'envoyais '010000100'
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Cela correspond à 0x42 plus le bit de parité.
\end_layout

\end_inset

, nous recevions parfois '100001000'.
 Par contre, si on lançait les programmes au bon moment, les données passaient
 très bien.
\end_layout

\begin_layout Standard
Pour corriger ce problème, nous avons décidé de rajouter, par rapport à
 ce que nous avions prévu en théorie, un bit de start, qui est unique, et
 qui ne peut pas être confondu avec un bit normal.
 Dès que nous avons rajouté ce bit de start, les octets étaient bien reçus,
 quelque soit la façon dont on démarrait les microcontrôleurs.
\end_layout

\begin_layout Subsection
Problème de lecture d'un paquet
\end_layout

\begin_layout Standard
Le même problème est apparu lorsque la couche 2
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
La couche MAC.
\end_layout

\end_inset

 lisait les octets pour former les paquets.
 Elle considérait le premier octet reçu comme le premier octet de la trame,
 donc cela pouvait créer un décalage.
 Pour corriger cette erreur, nous avons décidé de créer un octet de start,
 qui est aussi l'adresse source du paquet.
 En fait, nous avons décidé que toutes les adresses commenceraient par 101.
\end_layout

\begin_layout Standard
Donc, comme le paquet commence par l'adresse source, forcément, le premier
 octet doit être de la forme 101xxxxx.
\end_layout

\begin_layout Section
Le datasheet et la liaison série
\end_layout

\begin_layout Standard
Pour le déboguage, nous avons décidé d'utiliser la liaison série, car celle-ci
 est pratique, et facile à mettre en place.
 Mais, lorsque nous l'avons implémentée, nous nous sommes rendu compte que
 celle-ci ne fonctionnait pas.
 Après quelques recherche pour trouver l'origine, qui aurait pu être dans
 le max232, ou le convertiseur série-USB, nous l'avons trouvée, et elle
 venait du code.
 En effet, dans le datasheet, il était indiqué d'utiliser la formule suivante
 pour configurer le débit de la liaison série
\begin_inset space ~
\end_inset

: 
\begin_inset Formula $UBRR=\frac{f_{osc}}{2*BAUD}-1$
\end_inset

.
 Après analyse de la librairie serial de la carte arduino, nous nous sommes
 rendu compte que la formule qui fallait utiliser était la suivante
\begin_inset space ~
\end_inset

: 
\begin_inset Formula $UBRR=\frac{\frac{f_{osc}}{8*BAUD}-1}{2}$
\end_inset

.
 Il nous a suffit de changer la formule pour que la liaison série fonctionne
 correctement.
\end_layout

\begin_layout Chapter
Les résultats
\end_layout

\begin_layout Section
Emission et réception simultanées
\end_layout

\begin_layout Standard
Pour tester le fonctionnement de notre système, nous avons fait un premier
 test.
 Le principe de celui-ci est d'envoyer un caractère en continue, et en cas
 de réception d'un octet, afficher ce que nous avons reçu.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language={C++},numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

while(1)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (has_been_received)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		uart_send_char(received_byte);
\end_layout

\begin_layout Plain Layout

		has_been_received = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		emissionOctet('@');
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Test d'émission et réception en simultanée
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ensuite, nous avons relié entre eux 2 microcontrôleurs flashé avec ce programme
 pour observer le foncionnement de notre programme.
\end_layout

\begin_layout Standard
Le résultat est positif étant donné que les caractères sont envoyés un coup
 par l'un, un coup par l'autre, de manière aléatoire, sans qu'il y ait de
 caractère erroné, ou de chevauchement de caractère.
 Lorsque un microcontrôleur est en émission, l'autre ne peut absolument
 pas passer en émission.
\end_layout

\begin_layout Section
La couche haute
\end_layout

\begin_layout Standard
Pour utiliser notre programme, il suffit d'inclure la notre librairie avec
 la commande suivante
\begin_inset space ~
\end_inset

: 
\emph on
#include 
\begin_inset Quotes eld
\end_inset

mac.h
\begin_inset Quotes erd
\end_inset


\emph default
.
 Ensuite, il suffit d'envoyer des octets en appelent la fonction 
\emph on
void send( uint8_t address_dest, uint8_t data[16], uint8_t taille)
\emph default
.
 Cette fonction envoie un caractère dès que la ligne est libre.
\end_layout

\begin_layout Standard
Pour la réception, il suffit d'appeler la fonction 
\emph on
int8_t recv (uint8_t *src, uint8_t *taille, unsigned char *datas)
\emph default
.
 Cette fonction retourne un entier négatif en cas d'erreur de réception.
 Si l'entier est positif, c'est que l'entier est bien envoyé.
\end_layout

\begin_layout Part
Nos impressions
\end_layout

\begin_layout Chapter
Jérémy Cheynet
\end_layout

\begin_layout Section
Le langage C version microcontrôleur
\end_layout

\begin_layout Standard
Ma première surprise lorsque nous avons commencé ce PJ fut le langage C.
 J'avais l'habitude de programmer des microcontrôleurs en basic, ou en langage
 C arduino
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Langage C simplifié que l'on utilise avec la plateforme de développement
 arduino
\end_layout

\end_inset

.
 Il y a une différence de difficulté entre les 2 versions
\begin_inset space ~
\end_inset

: une version est très bas niveau avec écriture dans les registres et programmat
ion avec le datasheet à côté, tandis que l'autre version est beaucoup plus
 haut niveau, sans trop comprendre le principe de fonctionnement du système.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

int ledPin =  13;    // LED connected to digital pin 13
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void setup()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	pinMode(ledPin, OUTPUT);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void loop()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	digitalWrite(ledPin, HIGH); 
\end_layout

\begin_layout Plain Layout

	delay(1000);
\end_layout

\begin_layout Plain Layout

	digitalWrite(ledPin, LOW);
\end_layout

\begin_layout Plain Layout

	delay(1000);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example de code de type arduino
\begin_inset space ~
\end_inset

: faire clignoter une LED
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le code ci-dessus configure le port C, bit 5 en sorti (renomé pin 13 sur
 arduino) et le fait clignoter en le changeant d'état toute les secondes.
 Il est évident à comprendre, mais on ne sait pas trop ce qu'il se passe
 lorsque l'on fait le 
\emph on
pinMode
\emph default
, par exemple.
 Maintenant, voyons ce que cela donne en langage C avr
\begin_inset space ~
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=C,numbers=left,numberstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

#include <avr/io.h>
\end_layout

\begin_layout Plain Layout

#include <util/delay.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main (void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	DDRC |= ( 1 << DDC5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while(1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		PORTC |= ( 1 << PORTC5 );
\end_layout

\begin_layout Plain Layout

		_delay_ms(1000);
\end_layout

\begin_layout Plain Layout

		PORTC &= ~( 1 << PORTC5 );
\end_layout

\begin_layout Plain Layout

		_delay_ms(1000);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Example de code de type langage C avr
\begin_inset space ~
\end_inset

: faire clignoter une LED
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
On voit bien dans cette seconde version du même programme que comment fonctionne
 le système, où l'on écrit les 1 et les 0, les registres de configuration,
 etc ...
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Personnellement, je préfère la seconde méthode pour programmer, car l'on
 comprend beaucoup mieux ce qu'il se passe, et aujourd'hui, je pense être
 capable de programmer beaucoup plus facilement qu'avant.
\end_layout

\begin_layout Section
Git
\end_layout

\begin_layout Standard
Pour que l'on puisse travailler en parallèle, Yann a mis en place un répository
 git.
 J'ai donc du apprendre le fonctionnement de git, car jusque là, j'utilisais
 seulement des dépots svn.
 Cet outil est très pratique, mais un peu plus complexe à utiliser que svn.
 Peut-être que par la suite, j'utiliserai git, mais pour l'instant, je préfère
 quand même svn.
 Seul le futur me dira ce que j'utiliserai ...
\end_layout

\begin_layout Section
Résolution des problèmes
\end_layout

\begin_layout Standard
Losqu'un programme fonctionne du premier coup, ce n'est pas normal.
 Heureusement pour nous, nous sommes resté normaux, et nos programmes ont
 eu quelques bogues.
 C'est donc ainsi que nous avons appris à trouver les problèmes, et surtout
 les résoudre.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Pour la détection de problème, nous avons utilisé la liaison série.
 Nous avons donc appris à faire afficher des caractères ou des entiers utiles,
 et au bon endroit.
 La méthode que nous avons appliqué est de cibler fonction par fonction
 pour voir où se situe le problème.
 Une fois que nous l'avons trouvé, il ne restait plus qu'à le déboguer.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En général, le débugage est facile.
 On s'apperçoie vite de ce qu'il manque au programme.
 Mais parfois, on ne le sait pas.
 Ce fut le cas avec l'erreur du compilateur.
 Le programme fonctionnait très bien avec une compilation sans optimisation.
 Mais dès que l'on compilait avec une optimisation, le programme ne fonctionnait
 plus.
 Malheureusement pour nous, il était conseillé de compiler avec l'option
 d'optimisation pour éviter des 
\emph on
warnings
\emph default
 lors de la compilation d'une librairie.
 Et nous avons perdu un temps fou à chercher l'erreur dans notre programme,
 alors qu'il fallait aller voir les options de compilation.
 Maintenant, je serai au courant, ce qui m'évitera de perdre beaucoup de
 temps sur une chose comme ça.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
Je suis très content d'avoir fait ce programme, étant donné qu'il nous a
 permis de voir beaucoup de choses, de corriger des problèmes.
 Il m'a aussi montré que dans la théorie, nous oublions souvent des choses
 que nous gène dans la pratique car des problèmes que nous n'imaginons pas
 peuvent apparaitre.
\end_layout

\begin_layout Chapter
Yann Sionneau
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\end_body
\end_document
